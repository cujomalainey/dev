#!/usr/bin/env python3
# -*- coding: utf-8 -*-"
#
# Copyright 2020 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Module containing methods interfacing with gerrit.

i.e Create new bugfix change tickets, and reading metadata about a specific change.

Example CURL command that creates CL:
curl -b /home/chromeos_patches/.git-credential-cache/cookie \
        --header "Content-Type: application/json" \
        --data \
        '{"project":"chromiumos/third_party/kernel",\
        "subject":"test",\
        "branch":"chromeos-4.19",\
        "topic":"test_topic"}' https://chromium-review.googlesource.com/a/changes/
"""

from __future__ import print_function
import json
import http
import os
import re
import subprocess
import requests

import common

BUG_REGEX = re.compile(r'^BUG=(.*)$')
TEST_REGEX = re.compile(r'^TEST=(.*)$')

def get_auth_cookie():
    """Load cookies in order to authenticate requests with gerrit/googlesource."""
    # This cookie should exist on GCE in order to perform GAIA authenticated requests
    gerrit_credentials_cookies = http.cookiejar.MozillaCookieJar(common.GIT_COOKIE_PATH, None, None)
    gerrit_credentials_cookies.load()
    return gerrit_credentials_cookies

def retrieve_and_parse_endpoint(endpoint_url):
    """Retrieves Gerrit endpoint response and removes XSSI prefix )]}'"""
    try:
        resp = requests.get(endpoint_url, cookies=get_auth_cookie())
        resp.raise_for_status()
        resp_json = json.loads(resp.text[5:])
    except requests.exceptions.HTTPError as e:
        raise type(e)('Endpoint %s should have HTTP response 200' % endpoint_url) from e
    except json.decoder.JSONDecodeError as e:
        raise ValueError('Response should contain json )]} prefix to prevent XSSI attacks') from e

    return resp_json

def set_and_parse_endpoint(endpoint_url, payload):
    """POST request to gerrit endpoint with specified payload."""
    try:
        resp = requests.post(endpoint_url, json=payload, cookies=get_auth_cookie())
        resp.raise_for_status()
        resp_json = json.loads(resp.text[5:])
    except requests.exceptions.HTTPError as e:
        raise type(e)('Endpoint %s should have HTTP response 200' % endpoint_url) from e
    except json.decoder.JSONDecodeError as e:
        raise ValueError('Response should contain json )]} prefix to prevent XSSI attacks') from e

    return resp_json


def get_commit(changeid):
    """Retrieves current commit message for a change.

    May add some additional information to the fix patch for tracking purposes.
    i.e attaching a tag
    """
    get_commit_endpoint = os.path.join(common.CHROMIUM_REVIEW_BASEURL, 'changes',
                                        changeid, 'revisions/current/commit')
    resp = retrieve_and_parse_endpoint(get_commit_endpoint)

    try:
        return resp['message']
    except KeyError as e:
        raise type(e)('Gerrit API endpoint to get commit should contain message key') from e


def get_reviewers(changeid):
    """Retrieves list of reviewer emails from gerrit given a chromeos changeid."""
    list_reviewers_endpoint = os.path.join(common.CHROMIUM_REVIEW_BASEURL, 'changes',
                                        changeid, 'reviewers')

    resp = retrieve_and_parse_endpoint(list_reviewers_endpoint)

    try:
        return [reviewer_resp['email'] for reviewer_resp in resp]
    except KeyError as e:
        raise type(e)('Gerrit API endpoint to list reviewers should contain key email') from e

def set_reviewers(changeid, reviewer_emails):
    """Adds reviewers to a Gerrit CL."""
    add_reviewer_endpoint = os.path.join(common.CHROMIUM_REVIEW_BASEURL, 'changes',
                                        changeid, 'reviewers')

    for email in reviewer_emails:
        payload = {'reviewer': email}
        set_and_parse_endpoint(add_reviewer_endpoint, payload)

def get_change(changeid):
    """Retrieves ChangeInfo from gerrit using its changeid"""
    get_change_endpoint = os.path.join(common.CHROMIUM_REVIEW_BASEURL, 'changes',
                                        changeid)
    return retrieve_and_parse_endpoint(get_change_endpoint)

def set_hashtag(changeid):
    """Set hashtag to be autogenerated indicating a robot generated CL."""
    set_hashtag_endpoint = os.path.join(common.CHROMIUM_REVIEW_BASEURL, 'changes',
                                        changeid, 'hashtags')
    hashtag_input_payload = {'add' : ['autogenerated']}
    set_and_parse_endpoint(set_hashtag_endpoint, hashtag_input_payload)


def get_upstream_fullsha(abbrev_sha):
    """Returns the full upstream sha for an abbreviated 12 digit sha using git cli"""
    upstream_absolute_path = common.get_kernel_absolute_path(common.UPSTREAM_PATH)
    try:
        cmd = ['git', '-C', upstream_absolute_path, 'rev-parse', abbrev_sha]
        full_sha = subprocess.check_output(cmd).decode('utf-8')
        return full_sha.rstrip()
    except subprocess.CalledProcessError as e:
        raise type(e)('Could not find full upstream sha for %s' % abbrev_sha, e.cmd) from e


def get_upstream_commit_message(upstream_sha):
    """Returns the commit message for a given upstream sha using git cli."""
    upstream_absolute_path = common.get_kernel_absolute_path(common.UPSTREAM_PATH)
    try:
        cmd = ['git', '-C', upstream_absolute_path, 'log',
                '--format=%B', '-n', '1', upstream_sha]
        commit_message = subprocess.check_output(cmd).decode('utf-8', errors='ignore')
        return commit_message
    except subprocess.CalledProcessError as e:
        raise type(e)('Couldnt retrieve commit for upstream sha %s'
                        % upstream_sha, e.cmd) from e

def get_commit_changeid_linux_chrome(kernel_sha):
    """Returns the changeid of the most recent local commit by parsing linux_chrome git log."""
    chrome_absolute_path = common.get_kernel_absolute_path(common.CHROMEOS_PATH)
    try:
        cmd = ['git', '-C', chrome_absolute_path, 'log', '--format=%B', '-n', '1', kernel_sha]
        commit_message = subprocess.check_output(cmd).decode('utf-8', errors='ignore')

        m = re.findall('^Change-Id: (I[a-z0-9]{40})$', commit_message, re.M)

        # Get last change-id in case chrome sha cherry-picked/reverted into new commit
        return m[-1]
    except subprocess.CalledProcessError as e:
        raise type(e)('Couldnt retrieve changeid for most recent local commit', e.cmd) from e
    except IndexError as e:
        raise type(e)('Did not find Change-Id line for linux chrome sha %s' % kernel_sha) from e


def get_bug_test_line(fixee_changeid):
    """Retrieve BUG and TEST lines from the fixee changeid."""
    # stable fixes don't have a fixee changeid
    bug_test_line = 'BUG=%s\nTEST=%s'
    bug = test = None
    if not fixee_changeid:
        return bug_test_line % (bug, test)

    chrome_commit_msg = get_commit(fixee_changeid)

    bug_matches = re.findall('^BUG=(.*)$', chrome_commit_msg, re.M)
    test_matches = re.findall('^TEST=(.*)$', chrome_commit_msg, re.M)

    bug = bug_matches[0] if bug_matches else None
    test = test_matches[0] if test_matches else None

    return bug_test_line % (bug, test)

def generate_fix_message(fixer_upstream_sha, bug_test_line):
    """Generates new commit message for a fix change.

    Use script ./contrib/from_upstream.py to generate new commit msg
    Commit message should include essential information:
    i.e:
        FROMGIT, FROMLIST, ANDROID, CHROMIUM, etc.
        commit message indiciating what is happening
        BUG=...
        TEST=...
        tag for Fixes: <upstream-sha>
    """
    fix_upstream_commit_msg = get_upstream_commit_message(fixer_upstream_sha)

    upstream_full_sha = get_upstream_fullsha(fixer_upstream_sha)
    cherry_picked = '(cherry picked from commit %s)\n\n'% upstream_full_sha


    commit_message = ('UPSTREAM: {fix_commit_msg}'
                      '{cherry_picked}'
                      '{bug_test_line}').format(fix_commit_msg=fix_upstream_commit_msg,
                        cherry_picked=cherry_picked, bug_test_line=bug_test_line)

    return commit_message

def get_last_commit_sha_linux_chrome():
    """Retrieves the last SHA in linux_chrome repository."""
    chrome_absolute_path = common.get_kernel_absolute_path(common.CHROMEOS_PATH)
    cmd = ['git', '-C', chrome_absolute_path, 'rev-parse', 'HEAD']
    last_commit = subprocess.check_output(cmd).decode('utf-8')
    return last_commit.rstrip()

def cherry_pick_and_push_fix(fixer_upstream_sha, chromeos_branch, fix_commit_message):
    """Cherry picks upstream commit into chrome repo."""
    chrome_absolute_path = common.get_kernel_absolute_path(common.CHROMEOS_PATH)

    # reset linux_chrome repo to remove local changes
    try:
        os.chdir(chrome_absolute_path)
        subprocess.run(['git', 'checkout', chromeos_branch])
        subprocess.run(['git', 'reset', '--hard', 'origin/%s' % chromeos_branch])
        subprocess.run(['git', 'cherry-pick', '-n', fixer_upstream_sha])
        subprocess.run(['git', 'commit', '-s', '-m', fix_commit_message])

        # commit has been cherry-picked and committed locally, precommit hook
        #  in git repository adds changeid to the commit message
        last_commit = get_last_commit_sha_linux_chrome()
        fixer_changeid = get_commit_changeid_linux_chrome(last_commit)

        subprocess.run(['git', 'push', 'origin',
                            'HEAD:refs/for/%s%%t=autogenerated' % chromeos_branch])
        subprocess.run(['git', 'reset', '--hard', 'origin/%s' % chromeos_branch])

        return fixer_changeid
    except subprocess.CalledProcessError as e:
        raise ValueError('Failed to cherrypick and push upstream fix %s on branch %s'
                        % (fixer_upstream_sha, chromeos_branch)) from e
    finally:
        subprocess.run(['git', 'reset', '--hard', 'origin/%s' % chromeos_branch])
        os.chdir(common.WORKDIR)


# Note: Stable patches won't have a fixee_change_id since they come into chromeos as merges
def create_change(fixee_kernel_sha, fixer_upstream_sha, branch):
    """Creates a Patch in gerrit given a ChangeInput object.

    Determines whether a change for a fix has already been created,
    and avoids duplicate creations.
    """
    chromeos_branch = common.chromeos_branch(branch)

    fixee_changeid = get_commit_changeid_linux_chrome(fixee_kernel_sha)
    bug_test_line = get_bug_test_line(fixee_changeid)
    fix_commit_message = generate_fix_message(fixer_upstream_sha, bug_test_line)

    try:
        # Cherry pick changes and generate commit message indicating fix from upstream
        fixer_changeid = cherry_pick_and_push_fix(fixer_upstream_sha,
                                                    chromeos_branch, fix_commit_message)
    except ValueError:
        print('Failed to create gerrit ticket for [fixee_kernel_sha, fixer_upstream_sha]',
                (fixee_kernel_sha, fixer_upstream_sha))
        raise


    reviewers = None
    if fixee_changeid:
        # todo(hirthanan) change back to function call to retrieve reviewers
        # retrieve reviewers from gerrit for the relevant change
        reviewers = get_reviewers(fixee_changeid)
    else:
        # TODO(hirthanan): find relevant mailing list/reviewers
        # For now we will assign it to a default user like Guenter?
        # This is for stable bug fix patches that don't have a direct fixee changeid
        #  since groups of stable commits get merged as one changeid
        reviewers = ['groeck@chromium.org']

    set_reviewers(fixer_changeid, reviewers)

    return fixer_changeid
